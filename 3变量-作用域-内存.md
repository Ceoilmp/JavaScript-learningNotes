# 三、变量-作用域-内存

[TOC]

JavaScript的变量是松散类型的，变量不过就是特定时间点一个特定值的名称，由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。

## 3.1原始值和引用值

* 原始值：最简单的数据，保存原始值的变量是按值访问的，因为操作的就是存储在变量中的实际值
* 引用值：由多个值构成的对象，引用值是保存在内存中的对象，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的时对该对象的引用，而非实际的对象本身，为此，保存引用值的变量是按引用访问的

### 3.1.1动态属性

原始值不能有属性，尽管尝试给原始值添加属性不会报错

只有引用值可以动态添加后面可以使用的属性

原始类型的初始化可以只使用原始字面量形式，如果使用的是new关键字，JavaScript会创建一个Object类型的实例，但其行为类似于原始值

```js
let name1 = 'cmp'
let name2 = new String('mat')
name1.age = 27;
name2.age = 26;
console.log(name1.age); //undefined
console.log(name2.age); //26
console.log(typeof name1); //string
console.log(typeof name2); //object
```

### 3.1.2复制值

* 通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，两个值时完全独立的，这两个变量可以独立使用，互不干扰
* 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

```js
let obj1 = new Object()
let obj2 = obj1;
obj1.name = 'cmp'
console.log(obj2.name); //cmp
```

### 3.1.3传递参数

ECMAScript中所有函数的参数是按值传递的，则意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。

**传参数只有按值传递**

按值传递参数时，值会被复制到一个局部变量；在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数的外部

```js
//按值
function addTen(num){
    num += 10;
    return num;
}

let count = 20;
let result = addTen(count);
console.log(count); //20
console.log(result); //30

//传入一个对象
function addTen(obj){
    obj.count += 10;
    return obj.count;
}
let obj = new Object()
obj.count = 20;
let result = addTen(obj);
console.log(obj.count); //30
console.log(result); //30
```

***一种错误的看法***：当局部作用域修改对象而变化反映到全局时，就意味着参数是按引用传递的

```js
function setName(obj){
    obj.name = 'cmp'
    obj = new Object()
    obj.name = 'ceoilmp'
}

let person = new Object()
setName(person)
console.log(person.name); //cmp
```

如果person是按引用传递的，那么person应该自动将指针改为指向name为ceoilmp的对象。可是，当我们再次访问person.name时，它的值是cmp，这表明函数中参数的值改变后，原始的引用仍然没有改变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。

### 3.1.4确定类型

```js
console.log(typeof null); //object	
```

typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而时想知道他是什么类型的对象。ECMAScript提供了instanceof操作符

如果变量是给定引用类型的实例，则instanceof操作符返回true

## 3.2执行上下文与作用域

* 变量或函数的上下文决定了他们可以访问哪些数据，以及他们的行为

* 每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上，虽然这个变量对象无法通过代码访问，但后台在处理数据时会用到它
* 全局上下文是最外层的上下文，ECMAScript实现的宿主环境不同，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的window对象，因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文，但在作用链解析上效果是一样的。
* 上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数
* 每个函数调用都有自己的上下文，当代码执行流进入函数时，函数的上下文被推到一个上下文栈上，在函数执行完后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文，ECMAScript程序的执行流就是通过这个上下文栈进行控制的
* 局部作用域中定义的变量可用于在局部上下文中替换全局变量
* 内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西
* 函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则

### 3.2.1作用域链增强

某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常两种情况下会出现这个现象：

* try/catch语句的catch语句块，会创建一个新的变量对象，这个变量对象会包含要抛出错误对象的声明
* with语句，会向作用域链前端添加指定的对象

这两种情况，都会在作用域链前端添加一个变量对象。

```js
function buildUrl(){
    let qs = '?debug=true'

    with(location){
        let url = href + qs
    }

    return url
}
```

这里，with语句将location对象作为上下文，因此location会被添加到作用域链前端。buildUrl()函数中定义了一个变量qs。当with语句中的代码引用变量href时，实际上引用的是location.href，也就是自己变量对象的属性。在引用qs时，引用的则是定义在buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在with语句中使用var声明的变量url会成为函数上下文的一部分，可以作为函数的值被返回；这里使用let声明的变量url，因为被限制在块级作用域，所以with块之外没有定义

### 3.2.2变量声明

#### 3.2.2.1使用var的函数作用域声明

* 在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化，那么它就会自动被添加到全局上下文（严格模式下，未经声明就初始化变量会报错）

* var声明会被拿到函数或全局作用域的顶部，位于作用域中所有的代码之前。这个现象叫做提升。提升让同一个作用域的代码不必考虑变量是否已经声明就可以直接使用。

#### 3.2.2.2使用let的块级作用域声明

* let的作用域时块级，块级作用域由最近的一堆包含花括号界定
* let和var的另一个不同之处是在同一个作用域内不能声明两次，重复的var声明会被忽略，重复的let声明会抛出异常
* let的行为非常适合在循环中声明迭代变量，使用var声明的迭代变量会泄露到循环外部
* 严格来讲，let在JavaScript运行时也会被提升，但由于暂时性死区的缘故，实际上不能再声明之前使用let变量，因此，从写JavaScript代码的角度说，let的提升是不一样的

#### 3.2.2.3使用const的常量声明

* 使用const声明的变量必须同时初始化为某个值，一经声明，在其生命周期的任何时候都不能再重新赋予新值
* const其他方面和let声明是一样的
* const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能在被重新赋值为其他引用值，但对象的键则不受限制
* 如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败

```js
const o3 = {}
o3.name = 'cmp'
console.log(o3.name); //cmp

const o3 = Object.freeze({})
o3.name = 'cmp'
console.log(o3.name); //undefined
```

* 由于const声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所以实例都替换成实际的值，而不会通过查询表进行变量查找

#### 3.2.2.4标识符查找

* 当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。
* 作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链

## 3.3垃圾回收

JavaScript时垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。

基本思路：确定哪个变量不再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一段时间就会自动运行。垃圾回收是一个近似且不完美的方案，因为某块内存是否还有用，属于不可判定的问题，意味着靠算法是解决不了的

如何标记未使用的变量有不同的实现方式，浏览器的发展历史上，用到过两种标记策略，标记清理和引用计数

### 3.3.1标记清理

当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不再上下文中的变量，逻辑上讲，永远不应该释放他们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

垃圾回收程序运行时，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回他们的内存

### 3.3.2引用计数

对每个值都记录它会被引用的次数。声明一个变量并赋给它一个引用值时，这个值的引用数位1。如果同一个值又被赋给了另一个变量，那么引用数加1.类似的，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全的收回其内存了。

问题：**循环引用**：A对象有一个指针指向对象B，而对象B也引用了对象A，他们的引用数永远不会变为0，如果多次调用，会导致大量内存永远不会被释放

### 3.3.3性能

垃圾回收的时间调度

### 3.3.4内存管理

出于安全的考虑，浏览器分配的内存要比分配给桌面软件的内存小的多。

优化内存占用的最佳手段就是保证在执行diamagnetic时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用，这也叫**解除引用**。

* 通过let和const声明提升性能
* 隐藏类和删除操作：避免动态添加和删除属性，在构造函数中一次声明所有的属性
* 内存泄漏：
  * 意外声明全局变量时最常见但也最容易修复的内存泄露问题
  * 定时器也可能悄悄地导致内存泄漏
  * 闭包也可能在不知不觉间发生内存泄漏
* 静态分配与对象池：
  * 对象池：用来管理一组可回收的对象，应用程序可以向这个对象池请求一个对象，设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行
